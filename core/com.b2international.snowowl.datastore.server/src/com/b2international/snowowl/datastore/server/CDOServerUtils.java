/*
 * Copyright 2011-2017 B2i Healthcare Pte Ltd, http://b2i.sg
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.b2international.snowowl.datastore.server;

import static com.google.common.base.Preconditions.checkNotNull;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

import javax.annotation.Nullable;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.cdo.common.branch.CDOBranch;
import org.eclipse.emf.cdo.common.branch.CDOBranchPoint;
import org.eclipse.emf.cdo.common.branch.CDOBranchVersion;
import org.eclipse.emf.cdo.common.commit.CDOCommitInfo;
import org.eclipse.emf.cdo.common.commit.CDOCommitInfoHandler;
import org.eclipse.emf.cdo.common.id.CDOID;
import org.eclipse.emf.cdo.common.revision.CDORevision;
import org.eclipse.emf.cdo.eresource.EresourcePackage;
import org.eclipse.emf.cdo.internal.server.Repository;
import org.eclipse.emf.cdo.server.IRepository;
import org.eclipse.emf.cdo.server.IRepository.WriteAccessHandler;
import org.eclipse.emf.cdo.server.IStore;
import org.eclipse.emf.cdo.server.IStoreAccessor;
import org.eclipse.emf.cdo.server.StoreThreadLocal;
import org.eclipse.emf.cdo.server.db.IDBStore;
import org.eclipse.emf.cdo.server.db.IDBStoreAccessor;
import org.eclipse.emf.cdo.spi.common.commit.InternalCDOCommitInfoManager.CommitInfoLoader;
import org.eclipse.emf.cdo.spi.server.InternalCommitContext;
import org.eclipse.emf.cdo.spi.server.InternalRepository;
import org.eclipse.emf.cdo.spi.server.InternalSession;
import org.eclipse.emf.cdo.spi.server.InternalStore;
import org.eclipse.emf.cdo.spi.server.InternalTransaction;
import org.eclipse.emf.cdo.transaction.CDOTransaction;
import org.eclipse.emf.cdo.util.CommitException;
import org.eclipse.net4j.util.lifecycle.LifecycleUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.b2international.collections.PrimitiveLists;
import com.b2international.collections.longs.LongList;
import com.b2international.commons.CompareUtils;
import com.b2international.snowowl.core.ApplicationContext;
import com.b2international.snowowl.core.api.SnowowlServiceException;
import com.b2international.snowowl.datastore.CDOEditingContext;
import com.b2international.snowowl.datastore.cdo.CDOServerCommitBuilder;
import com.b2international.snowowl.datastore.cdo.CDOTransactionAggregator;
import com.b2international.snowowl.datastore.cdo.CDOUtils;
import com.b2international.snowowl.datastore.cdo.CustomTransactionCommitContext;
import com.b2international.snowowl.datastore.cdo.ICDOConnection;
import com.b2international.snowowl.datastore.cdo.ICDOConnectionManager;
import com.b2international.snowowl.datastore.cdo.ICDOTransactionAggregator;
import com.b2international.snowowl.datastore.cdo.IErrorLoggingStrategy;
import com.google.common.base.Preconditions;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

/**
 * Sugar for server side CDO usage.
 * <p>
 * <b>NOTE:&nbsp;</b>This class is heavily depends on server side services 
 * registered to the application context. Be smart when moving this class to other plug-in.
 */
@SuppressWarnings("restriction")
public abstract class CDOServerUtils {

	private static final Logger LOGGER = LoggerFactory.getLogger(CDOServerUtils.class);

	/**
	 * Commits the specified {@link CDOEditingContext}'s transaction with someone else user ID to the backend.
	 * @param context
	 * @param userId
	 * @param comment
	 * @param monitor
	 * @return
	 * @throws CommitException
	 */
	public static CDOCommitInfo commit(final CDOEditingContext context, final String userId, @Nullable final String comment, @Nullable final IProgressMonitor monitor) throws CommitException {
		return commit(context.getTransaction(), userId, comment, monitor);
	}
	
	/**
	 * Commits the specified transaction with someone else user ID to the backend.
	 * @param transaction the transaction to commit.
	 * @param userId the unique ID of the user.
	 * @param comment comment for the commit.
	 * @param monitor monitor for the progress. Can be {@code null}.
	 * @return the commit information containing the changes generated by persisting the change set wrapped by the current transaction.
	 * @throws CommitException if the commit failed.
	 */
	public static CDOCommitInfo commit(final CDOTransaction transaction, final String userId, @Nullable final String comment, 
			@Nullable final IProgressMonitor monitor) throws CommitException {
		
		return commit(transaction, userId, comment, true, monitor);
	}
	
	/**
	 * Commits the specified transaction with someone else user ID to the backend.
	 * @param transaction the transaction to commit.
	 * @param userId the unique ID of the user.
	 * @param comment comment for the commit.
	 * @param notifyWriteAccessHandlers {@code true} if all registered {@link WriteAccessHandler} registered to the {@link IRepository} instance
	 * should be notified after a successful backend commit, otherwise {@code false}. 
	 * @param monitor monitor for the progress. Can be {@code null}.
	 * @return the commit information containing the changes generated by persisting the change set wrapped by the current transaction.
	 * @throws CommitException if the commit failed.
	 */
	public static CDOCommitInfo commit(final CDOTransaction transaction, final String userId, @Nullable final String comment, 
			final boolean notifyWriteAccessHandlers, @Nullable final IProgressMonitor monitor) throws CommitException {
		
		return Iterables.getOnlyElement(commit(Collections.singleton(transaction), userId, comment, notifyWriteAccessHandlers, monitor));
	}
	
	/**
	 * Commits the specified transaction with someone else user ID to the backend.
	 * @param transactions the transactions to commit.
	 * @param userId the unique ID of the user.
	 * @param comment comment for the commit.
	 * @param notifyWriteAccessHandlers {@code true} if all registered {@link WriteAccessHandler} registered to the {@link IRepository} instance
	 * should be notified after a successful backend commit, otherwise {@code false}. 
	 * @param monitor monitor for the progress. Can be {@code null}.
	 * @return the commit information containing the changes generated by persisting the change set wrapped by the current transaction.
	 * @throws CommitException if the commit failed.
	 */
	public static Iterable<CDOCommitInfo> commit(final Iterable<CDOTransaction> transactions, final String userId, @Nullable final String comment, 
			final boolean notifyWriteAccessHandlers, @Nullable final IProgressMonitor monitor) throws CommitException {
		
		return commit(CDOTransactionAggregator.create(transactions), userId, comment, notifyWriteAccessHandlers, monitor);
	}

	/**
	 * Commits the specified transaction with someone else user ID to the backend.
	 * @param transactionAggregator an aggregator encapsulating an arbitrary number of CDO transactions.
	 * @param userId the unique ID of the user.
	 * @param comment comment for the commit.
	 * @param notifyWriteAccessHandlers {@code true} if all registered {@link WriteAccessHandler} registered to the {@link IRepository} instance
	 * should be notified after a successful backend commit, otherwise {@code false}.
	 * @param sendCommitNotification {@code true} is {@link InternalRepository#sendCommitNotification(InternalSession, CDOCommitInfo)} should be invoked
	 * after successful commit, otherwise {@code false}.
	 * @param monitor monitor for the progress. Can be {@code null}.
	 * @return the commit information containing the changes generated by persisting the change set wrapped by the current transaction.
	 * @throws CommitException if the commit failed.
	 */
	public static Iterable<CDOCommitInfo> commit(final ICDOTransactionAggregator transactionAggregator, final String userId, @Nullable final String comment, 
			final boolean notifyWriteAccessHandlers, @Nullable final IProgressMonitor monitor) throws CommitException {
		
		return commit(transactionAggregator, userId, comment, notifyWriteAccessHandlers, true, monitor);
	}
	
	/**
	 * Commits the specified transaction with someone else user ID to the backend.
	 * @param transactionAggregator an aggregator encapsulating an arbitrary number of CDO transactions.
	 * @param userId the unique ID of the user.
	 * @param comment comment for the commit.
	 * @param notifyWriteAccessHandlers {@code true} if all registered {@link WriteAccessHandler} registered to the {@link IRepository} instance
	 * should be notified after a successful backend commit, otherwise {@code false}.
	 * @param sendCommitNotification {@code true} is {@link InternalRepository#sendCommitNotification(InternalSession, CDOCommitInfo)} should be invoked
	 * after successful commit, otherwise {@code false}.
	 * @param monitor monitor for the progress. Can be {@code null}.
	 * @return the commit information containing the changes generated by persisting the change set wrapped by the current transaction.
	 * @throws CommitException if the commit failed.
	 */
	public static Iterable<CDOCommitInfo> commit(final ICDOTransactionAggregator transactionAggregator, final String userId, @Nullable final String comment, 
			final boolean notifyWriteAccessHandlers, final boolean sendCommitNotification, @Nullable IProgressMonitor monitor) throws CommitException {
		
		return new CDOServerCommitBuilder(userId, comment, transactionAggregator)
			.notifyWriteAccessHandlers(notifyWriteAccessHandlers)
			.sendCommitNotification(sendCommitNotification)
			.commit(monitor);
	}
	/**
	 * Performs a {@link InternalRepository#sendCommitNotification(InternalSession, CDOCommitInfo)} on the 
	 * {@link InternalRepository repository} associated with the {@link CDOCommitInfo commit info} argument.
	 * <br>This method does nothing if the {@link CDOCommitInfo commit info} argument is either {@code null} 
	 * or representing a failed commit.
	 * @param commitInfo the commit info to send.
	 */
	public static void sendCommitNotification(@Nullable final CDOCommitInfo commitInfo) {
		
		if (null != commitInfo && commitInfo.getBranch() instanceof CDOBranch) {
				
			InternalSession session = null;
			
			try {

				final ICDOConnection connection = getConnectionManager().get(commitInfo.getBranch());
				final String repositoryUuid = connection.getUuid();
				final InternalRepository repository = CDOUtils.getRepositoryByUuid(repositoryUuid);
				
				session = CDOUtils.openSession(commitInfo.getUserID(), repositoryUuid);
				
//				final CDOCommitInfo delegateCommitInfo = CDOCommitInfoUtils.removeUuidFromComment(commitInfo);
				repository.sendCommitNotification(session, commitInfo);
				
			} finally {
				
				LifecycleUtil.deactivate(session);
				
			}
			
		}
			
		
	}
	
	/**
	 * Returns with the revisions for the given CDO IDs on a specified {@link CDOBranchPoint branch point}.
	 * @param branchPoint the branch point to get the revisions.
	 * @param ids the CDO IDs.
	 * @return a list of CDO revisions.
	 */
	public static List<CDORevision> getRevisions(final CDOBranchPoint branchPoint, final CDOID... ids) {
		return CDOUtils.getRevisions(branchPoint, Arrays.asList(ids));
	}

	/**
	 * Returns with the revision of an object given by its unique storage key from the {@link CDOBranchVersion branch version}.
	 * <br>May return with {@code null} if the object cannot be found.
	 * @param branchVersion the version of a CDO branch.
	 * @param id the unique CDO ID of an object.
	 * @return the revision of the object or {@code null}.
	 */
	@Nullable public static CDORevision getRevision(final CDOBranchVersion branchVersion, final CDOID id) {
		
		try {
			
			StoreThreadLocal.setAccessor(getAccessor(id));
			
			//get revisions at once
			return CDOUtils.getRevisionManager(id).getRevisionByVersion(
					id, 
					branchVersion, 
					CDORevision.UNCHUNKED,
					true);
			
			
			
		} finally {
			
			//release resources
			StoreThreadLocal.release();
			
		}
		
	}
	
	/**
	 * Returns with the last commit time made on the given branch.
	 * <br>This method will return with {@link Long#MIN_VALUE} if no modification has been
	 * made on the given branch, hence no commit time is associated with it.  
	 * @param branch
	 * @return
	 */
	public static long getLastCommitTime(final CDOBranch branch) {
		
		Preconditions.checkNotNull(branch, "CDO branch argument cannot be null.");
		final String uuid = getConnectionManager().get(branch).getUuid();
		
		try {
			
			IDBStoreAccessor accessor = ACCESSOR_CACHE.get(uuid);
			
			synchronized (accessor) {
				Connection connection = accessor.getConnection();
				connection.rollback();
		
				try (PreparedStatement statement = connection.prepareStatement("SELECT MAX(COMMIT_TIME) FROM CDO_COMMIT_INFOS WHERE BRANCH_ID=?")) {
					statement.setInt(1, branch.getID());
					ResultSet resultSet = statement.executeQuery();
					final long lastCommitTime = resultSet.next() ? resultSet.getLong(1) : Long.MIN_VALUE;
					return getDbStoreByUuid(uuid).getCreationTime() > lastCommitTime ? Long.MIN_VALUE : lastCommitTime;
				}
			}
			
		} catch (final ExecutionException e) {
			throw new RuntimeException("Failed to get last commit time for branch: " + branch, e);
		} catch (final SQLException e) {
			throw new RuntimeException("Failed to get last commit time for branch: " + branch, e);
		}
	}

	/**
	 * Wraps the specified {@link Runnable} into another one that manages the thread-local store accessor, unsetting it when the wrapped runnable
	 * completes.
	 * 
	 * @param runnable
	 * @param accessor
	 * @return
	 */
	public static Runnable withAccessor(final Runnable runnable, final IStoreAccessor accessor) {
		return new Runnable() {
			@Override
			public void run() {
				try {
					StoreThreadLocal.setAccessor(accessor);
					runnable.run();
				} finally {
					StoreThreadLocal.setAccessor(null);
				}
			}
		};
	}
	
	/**Returns with the store accessor for a given repository.<br>Never {@code null}.*/
	public static IStoreAccessor getAccessorByUuid(final String uuid) {
		return Preconditions.checkNotNull(getDbStoreByUuid(uuid).getWriter(null), "Store accessor was null for repository: " + uuid);
	}

	/**Returns with the store accessor for an object given as its CDO ID argument.<br>Never {@code null}.*/
	public static IDBStoreAccessor getAccessor(final long cdoId) {
		return checkNotNull(getDbStore(cdoId).getWriter(null), "Store accessor was null. CDO ID: " + cdoId);
	}

	/**Creates and initialize a {@link IRepository repository} instance with the given name, backing store, configuration and error logging strategy,*/
	public static IRepository createRepository(final String name, final IStore store, final Map<String, String> properties, final IErrorLoggingStrategy strategy) {
    
		Preconditions.checkNotNull(name, "name");
		Preconditions.checkNotNull(store, "store");
		Preconditions.checkNotNull(properties, "properties");
		Preconditions.checkNotNull(strategy, "strategy");
		
		final Repository repository = new Repository.Default() {
			@Override public InternalCommitContext createCommitContext(final InternalTransaction transaction) {
				return new CustomTransactionCommitContext(transaction, strategy);
			}
		};
    
    repository.setName(name);
    repository.setStore((InternalStore) store);
    repository.setProperties(properties);
    
    return repository;
  }
	
	/** Cache storing a dedicated {@link IDBStoreAccessor} for retrieving latest commit timestamps for each repository. */
	private static final LoadingCache<String, IDBStoreAccessor> ACCESSOR_CACHE = CacheBuilder.newBuilder().build(new CacheLoader<String, IDBStoreAccessor>() {
		@Override public IDBStoreAccessor load(final String uuid) throws Exception {
			Preconditions.checkNotNull(uuid, "Repository UUID argument cannot be null.");
			return (IDBStoreAccessor) getAccessorByUuid(uuid);
		}
	});
	
	/*returns with the connection manager.*/
	private static ICDOConnectionManager getConnectionManager() {
		return ApplicationContext.getInstance().getService(ICDOConnectionManager.class);
	}

	/*returns with the DB accessor*/
	private static IDBStoreAccessor getAccessor(final CDOID cdoId) {
		return CDOUtils.getAccessor(cdoId);
	}
	
	/*returns with the DB store*/
	private static IDBStore getDbStore(final long cdoId) {
		return (IDBStore) CDOUtils.getRepository(cdoId).getStore();
	}
	
	/*returns with the DB store*/
	private static IDBStore getDbStoreByUuid(final String uuid) {
		return (IDBStore) CDOUtils.getRepositoryByUuid(uuid).getStore();
	}
	
	/*returns true if the given list of revisions is null, empty or the only element is null. otherwise, false*/
	private static boolean emptyOrNullRevision(final List<CDORevision> revisions) {
		return CompareUtils.isEmpty(revisions) || null == Iterables.getOnlyElement(revisions, null);
	}
	
	private CDOServerUtils() {
		//suppress instantiation
	}
	
}
